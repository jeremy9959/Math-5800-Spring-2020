<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Convolution</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide section level1">

<h3 id="setting-up">Setting up</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">from</span> bokeh.plotting <span class="im">import</span> figure</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="im">from</span> bokeh.io <span class="im">import</span> output_notebook, show,curdoc</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="im">from</span> bokeh.themes <span class="im">import</span> Theme</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">output_notebook()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">theme<span class="op">=</span>Theme(json<span class="op">=</span>{})</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">curdoc().theme<span class="op">=</span>theme</a></code></pre></div>
<div class="bk-root">
<pre><code>&lt;a href=&quot;https://bokeh.org&quot; target=&quot;_blank&quot; class=&quot;bk-logo bk-logo-small bk-logo-notebook&quot;&gt;&lt;/a&gt;
&lt;span id=&quot;1001&quot;&gt;Loading BokehJS ...&lt;/span&gt;</code></pre>
</div>
<h2 id="convolution">Convolution</h2>
<p>Convolution is a fundamental operation that appears in many different contexts in both pure and applied settings in mathematics.</p>
<h4 id="polynomials-a-simple-case">Polynomials: a simple case</h4>
<p>Let’s look at a simple case first. Consider the space of real valued polynomial functions <span class="math inline">\(\mathcal{P}\)</span>.</p>
<p>If <span class="math inline">\(f\in \mathcal{P}\)</span>, we have</p>
<p><span class="math display">\[
f(z) = \sum_{i=0}^{\infty} a_i z^i
\]</span></p>
<p>where <span class="math inline">\(a_i=0\)</span> for <span class="math inline">\(i\)</span> sufficiently large. There is an obvious linear map</p>
<p><span class="math display">\[
a:\mathcal{P}\to c_{00}(\mathbf{R})
\]</span></p>
<p>where <span class="math inline">\(c_{00}(\mathbf{R})\)</span> is the space of sequences that are eventually zero.</p>
<p>For each integer <span class="math inline">\(i\)</span>, we have a projection map <span class="math inline">\(a_{i}:c_{00}(\mathbf{R})\to\mathbf{R}\)</span> so that <span class="math inline">\(a_{i}(f)\)</span> is the coefficient of <span class="math inline">\(z^{i}\)</span> for <span class="math inline">\(f\in\mathcal{P}\)</span>.</p>
<p>Since <span class="math inline">\(\mathcal{P}\)</span> is a ring under addition and multiplication of functions, these operations must be reflected on the other side of the map <span class="math inline">\(a\)</span>.</p>
<p>Clearly we can add sequences in <span class="math inline">\(c_{00}(\mathbf{R})\)</span> componentwise, and since addition of polynomials is also componentwise we have: <span class="math display">\[
a(f+g)=a(f)+a(g)
\]</span></p>
<p>What about multiplication? We know that</p>
<p><span class="math display">\[
a_{n}(fg) = \sum_{r+s=n}a_{r}(f)a_{s}(g) = \sum_{r=0}^{n} a_{r}(f)a_{n-r}(g) = \sum_{r=0}^{\infty}a_{r}(f)a_{n-r}(g)
\]</span> where we adopt the convention that <span class="math inline">\(a_i(f)=0\)</span> if <span class="math inline">\(i&lt;0\)</span>.</p>
<p>Given <span class="math inline">\((a_0,a_1,\ldots)\)</span> and <span class="math inline">\((b_0,b_1,\ldots)\)</span> in <span class="math inline">\(c_{00}(\mathbf{R})\)</span>, define <span class="math display">\[
a*b = (c_0,c_1,\ldots)
\]</span> where <span class="math display">\[
c_n = \sum_{j=0}^{\infty} a_j b_{n-j}
\]</span> with the same convention that <span class="math inline">\(a_i=b_i=0\)</span> if <span class="math inline">\(i&lt;0\)</span>.</p>
<p>This operation is called <em>convolution</em>; together with addition it makes the vector space <span class="math inline">\(c_{00}(\mathbf{R})\)</span> into a commutative ring with identity element <span class="math inline">\((1,0,0,\ldots)\)</span>. Furthermore by construction we have</p>
<p><span class="math display">\[
a(fg) = a(f)*a(g).
\]</span></p>
<h4 id="some-generalizations---infinite-series">Some generalizations - infinite series</h4>
<p>There are many generalizations of this.</p>
<ul>
<li><p>we may consider infinite series, not just polynomials. If <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are such series, we can set <span class="math inline">\(c=(c_r)\)</span> where <span class="math inline">\(c_r=\sum_{r=0}^{\infty}a_r b_{n-r}\)</span> and as usual set <span class="math inline">\(a_i=b_i=0\)</span> if <span class="math inline">\(i&lt;0\)</span>. Then this sum only involves finitely many terms.</p></li>
<li><p>we can consider infinite series that have a given radius convergence, or that have non-zero radius of convergence. Since the product of convergent series is convergent and the coefficients are computed as if the series were (infinite) polynomials, we can extend convolution to this vector space.</p></li>
</ul>
<h4 id="fourier-series">Fourier Series</h4>
<p>A function <span class="math inline">\(f(z)\)</span> in <span class="math inline">\(L^{2}(S^{1})\)</span> has a Fourier Series <span class="math inline">\(\sum_{n=-\infty}^{\infty} a_{n}e^{2\pi i nz}\)</span> where</p>
<p><span class="math display">\[
a_n = \int_{S^{1}} f(z)e^{-2\pi inz}dz.
\]</span></p>
<p>These coefficients can be assembled to give a linear map</p>
<p><span class="math display">\[
F: L^{2}(S^{1})\to \ell^{2}(\mathbf{Z})
\]</span></p>
<p>where <span class="math inline">\(\ell^{2}(\mathbf{Z})\)</span> is the space of functions <span class="math inline">\(h:\mathbf{Z}\to\mathbf{C}\)</span> where <span class="math inline">\(\sum_{n=-\infty}^{\infty} \|h(n)\|^2&lt;\infty\)</span>.</p>
<p>Then <span class="math inline">\(F(fg)=F(f)*F(g)\)</span>. Here, the sum giving the Fourier coefficient of the product</p>
<p><span class="math display">\[
c(n) = \sum_{r=-\infty}^{\infty} a(r)b(n-r)
\]</span> is infinite and you need the <span class="math inline">\(L^2\)</span> condition to show that it converges.</p>
<p><strong>Proposition:</strong> The coefficients of the Fourier series of the product of periodic functions is the convolution of the original functions’ Fourier coefficients.</p>
<p>The convolution of two functions <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> on the real line is given by the integral</p>
<p><span class="math display">\[
(f*g)(\theta) = \int f(\phi)g(\theta-\phi) d\phi.
\]</span></p>
<p>This is a continuous version of the fourier series situation, and you can show that, with the right convergence conditions, that <strong>the fourier transform of the product of functions is the convolution of their fourier transforms.</strong></p>
<h4 id="inverse-transform">Inverse transform</h4>
<p>One last remark. Suppose that <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are functions on <span class="math inline">\(S^{1}\)</span>. Their convolution is given by the integral</p>
<p><span class="math display">\[
(f*g)(z) = \int_{S^{1}} f(\theta)g(z-\theta)d\theta.
\]</span></p>
<p>The fourier coefficients of the convolution are:</p>
<p><span class="math display">\[
a_n(f*g)=\int_{S^{1}}\int_{S^{1}} f(\theta)g(z-\theta)dz\  e^{-2\pi i n\theta}d\theta.
\]</span></p>
<p>Make the substitution <span class="math inline">\(\theta=z-u\)</span> and the integral splits up to give <span class="math display">\[
a_n(f*g)=a_n(f)a_n(g).
\]</span></p>
<p>So the <strong>Fourier transform of the convolution is the pointwise product of the fourier transforms.</strong></p>
<p>This holds in the case of the Fourier transform on <span class="math inline">\(\mathbf{R}\)</span> as well, with appropriate convergence assumptions.</p>
<h2 id="an-example">An example</h2>
<p>Suppose that <span class="math inline">\(f(x)\)</span> is a function on the real line, and <span class="math inline">\(g(x)\)</span> is a square bump <span class="math display">\[
g(x) = \begin{cases} 1 &amp; 0\le x\le 1 \cr 0 &amp; \hbox{otherwise}\end{cases}
\]</span></p>
<p>Then <span class="math display">\[
(f*g)(y) = \int f(x)g(y-x)dx = \int_{x=y-1}^{y} f(x) dx.
\]</span></p>
<p>In other words the value of <span class="math inline">\(f*g\)</span> at <span class="math inline">\(y\)</span> is the average value of <span class="math inline">\(f\)</span> over the preceeding unit interval – <span class="math inline">\(f*g\)</span> is a “moving average” of <span class="math inline">\(f\)</span>.</p>
<p>Let’s see how convolution acts like a filtering operation. First we construct a “noisy” sine wave in python and plot it.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1">x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">20</span>,<span class="dv">20</span>,<span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">y <span class="op">=</span> np.sin(x)<span class="op">+</span>np.random.normal(<span class="dv">0</span>,.<span class="dv">3</span>,size<span class="op">=</span>x.shape[<span class="dv">0</span>])</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1">F<span class="op">=</span>figure(height<span class="op">=</span><span class="dv">300</span>,width<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">F.line(x,y,legend_label<span class="op">=</span><span class="st">&#39;noisy&#39;</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">show(F)</a></code></pre></div>
<div id="8e6472ac-3372-4565-8f98-d2a18536fafd" class="bk-root" data-root-id="1225">

</div>
<p>The <code>np.linspace(a,b,n)</code> function constructs an array <span class="math inline">\((x_i)\)</span> where <span class="math inline">\(x_0=a\)</span>, <span class="math inline">\(\Delta=(b-a)/n\)</span>, and</p>
<p><span class="math display">\[
x_i = x_0+i\Delta
\]</span></p>
<p>for <span class="math inline">\(i=0,\ldots, n-1\)</span>. We can approximate the convolution of <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> by the Riemann sum</p>
<p><span class="math display">\[
(f*g)(x_j) = \sum_{i=0}^{n-1} f(x_i)g(x_j-x_i)\Delta = \sum_{i=0}^{n-1}f(x_i)g((j-i)\Delta)\Delta
\]</span></p>
<p>provided we assume that <span class="math inline">\(f\)</span> is zero outside of the interval from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span>. So if we have the array of values <span class="math inline">\(f(x_i)\)</span> and we can compute <span class="math inline">\(g\)</span>, we can approximate the convolution as a finite sum.</p>
<p><strong>Exercise:</strong> Look at the documentation for the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html">numpy convolve function</a>. What is the significance of the ‘mode’ options ‘valid’, ‘same’, and ‘full’?</p>
<p>In the code below, I choose the option ‘same’ which means that the arrays are padded with zeros so that the convolution has the same length as the original arrays.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1">f <span class="op">=</span> np.vectorize(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="cf">if</span> x<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> x<span class="op">&lt;=</span><span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">g<span class="op">=</span>f(x)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co"># 1/sum(g) is delta for the riemann sum</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">fstarg <span class="op">=</span> np.convolve(y,g,<span class="st">&#39;same&#39;</span>)<span class="op">/</span><span class="bu">sum</span>(g)</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1">F <span class="op">=</span> figure(height<span class="op">=</span><span class="dv">400</span>,width<span class="op">=</span><span class="dv">400</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">F.line(x,y,legend_label<span class="op">=</span><span class="st">&#39;noisy&#39;</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">F.line(x,fstarg,color<span class="op">=</span><span class="st">&#39;green&#39;</span>,legend_label<span class="op">=</span><span class="st">&#39;smoothed&#39;</span>,line_width<span class="op">=</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">F.legend.background_fill_alpha<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">F.legend.click_policy<span class="op">=</span><span class="st">&#39;hide&#39;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">F.title.text<span class="op">=</span><span class="st">&quot;A noisy signal and convolution with a square wave&quot;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">show(F)</a></code></pre></div>
<div id="5b682be3-caae-4368-b07e-ef9164447c85" class="bk-root" data-root-id="1689">

</div>
<p>The convolution smooths out the noisy sine wave, but also introduces a small phase shift. (Why?)</p>
<h2 id="convolution-in-two-dimensions">Convolution in two dimensions</h2>
<p>Just like in one dimension, convolution is a type of filtering operation in two dimensions. The most direct generalization of the example at the beginning of this note would be to consider a function <span class="math inline">\(f(x,y)\)</span> of two variables (our “image”), and take <span class="math inline">\(g(x,y)\)</span> to be the function taking the value <span class="math inline">\(1\)</span> on a square centered at the origin and zero elsewhere. Then the convolution <span class="math inline">\(f*g\)</span> would make a new image whose value at a point is the average of the values at the nearby points in a square region.</p>
<p>Let’s grab a few MNIST images and do some experiments.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="im">import</span> pandas <span class="im">as</span> pd</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="im">from</span> scipy.signal <span class="im">import</span> convolve2d</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="im">from</span> bokeh.layouts <span class="im">import</span> row, column</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">theme <span class="op">=</span> Theme(json<span class="op">=</span>{<span class="st">&#39;attrs&#39;</span>:{<span class="st">&#39;Figure&#39;</span>:{<span class="st">&#39;toolbar_location&#39;</span>:<span class="va">None</span>},<span class="st">&#39;Grid&#39;</span>:{<span class="st">&#39;visible&#39;</span>: <span class="va">False</span>}, <span class="st">&#39;Axis&#39;</span>:{<span class="st">&#39;visible&#39;</span>:<span class="va">False</span>}}})</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">curdoc().theme<span class="op">=</span>theme</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">images <span class="op">=</span> pd.read_csv(<span class="st">&#39;../data/MNIST/train.csv&#39;</span>,nrows<span class="op">=</span><span class="dv">50</span>)</a></code></pre></div>
<p>Let’s also make three “stop functions”, one of which is just a 3x3 bump, and the other two are vertical and horizontal lines.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1">K <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">KV <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]])</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">KH <span class="op">=</span> np.array([[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]])</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1">F <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">pic <span class="op">=</span> images.iloc[<span class="dv">1</span>,<span class="dv">1</span>:].values.reshape(<span class="dv">28</span>,<span class="dv">28</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">F.image(image<span class="op">=</span>[pic],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>,palette<span class="op">=</span><span class="st">&#39;Spectral11&#39;</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">F.title.text<span class="op">=</span><span class="st">&#39;An MNIST 0 (unfiltered)&#39;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">F1 <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">F1.image(image<span class="op">=</span>[convolve2d(pic,K)<span class="op">/</span><span class="dv">9</span>],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>,palette<span class="op">=</span><span class="st">&#39;Spectral11&#39;</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">F1.title.text<span class="op">=</span><span class="st">&quot;Averaging Filter&quot;</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">F2 <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">F2.image(image<span class="op">=</span>[convolve2d(pic,KV)<span class="op">/</span><span class="dv">3</span>],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>,palette<span class="op">=</span><span class="st">&#39;Spectral11&#39;</span>)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">F2.title.text<span class="op">=</span><span class="st">&quot;Vertical line filter&quot;</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">F3 <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">F3.image(image<span class="op">=</span>[convolve2d(pic,KH)<span class="op">/</span><span class="dv">3</span>],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>,palette<span class="op">=</span><span class="st">&#39;Spectral11&#39;</span>)</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">F3.title.text<span class="op">=</span><span class="st">&quot;Horizontal line filter&quot;</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">show(column(row(F,F1),row(F2,F3)))</a></code></pre></div>
<div id="d92b6016-6a06-4948-a5b0-c19f3eea4fca" class="bk-root" data-root-id="7003">

</div>
</div>
<div id="color-images" class="slide section level1">
<h1>Color Images</h1>
<p>We’ll take a pokemon image which is an RGBA image – meaning it has 4 channels, one each for Red, Green, Blue, and Alpha (or transparency). Since the image is 120x120, it gives an array of dimensions 120x120x4. We will mostly ignore the last (alpha) layer when working with image.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="im">import</span> imageio</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">image <span class="op">=</span> imageio.imread(<span class="st">&#39;../data/pokemon/delcatty.png&#39;</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="im">from</span> scipy.ndimage.filters <span class="im">import</span> convolve</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="im">from</span> scipy.ndimage.filters <span class="im">import</span> gaussian_filter</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">K <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">H <span class="op">=</span> np.stack([K,K,K,K])</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">H<span class="op">=</span>H.transpose(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>)<span class="op">/</span>H.<span class="bu">sum</span>()</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">filtered<span class="op">=</span>convolve(image,H)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">F <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">F.image_rgba(image<span class="op">=</span>[image[::<span class="op">-</span><span class="dv">1</span>,::<span class="op">-</span><span class="dv">1</span>,:]],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">F.title.text <span class="op">=</span> <span class="st">&quot;original pokemon&quot;</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">F2 <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">300</span>,height<span class="op">=</span><span class="dv">300</span>)</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">F2.image_rgba(image<span class="op">=</span>[filtered[::<span class="op">-</span><span class="dv">1</span>,::<span class="op">-</span><span class="dv">1</span>,:]],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>,)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">F2.title.text<span class="op">=</span><span class="st">&quot;pokemon with an averaging filter&quot;</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">F.xgrid.visible<span class="op">=</span><span class="va">False</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">F.ygrid.visible<span class="op">=</span><span class="va">False</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">F2.xgrid.visible<span class="op">=</span><span class="va">False</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21">F2.ygrid.visible<span class="op">=</span><span class="va">False</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">show(row(F,F2))</a></code></pre></div>
<div id="f47a2819-7c26-499c-a2a3-98129891030f" class="bk-root" data-root-id="7630">

</div>
<p>A gaussian filter means that instead of convolving our image with a “step function” we convolve with a Gaussian. This gives a weighted average for the pixel value at each point. The variance of the Gaussian affects the range over which the averaging is conducted. In the example below, we image our image sits in an infinite plane of zeros for purposes of computing the convolution.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1"></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">def</span> filter_image():</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    ims <span class="op">=</span> []</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="cf">for</span> sigma <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">1</span>):</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">        F <span class="op">=</span> figure(width<span class="op">=</span><span class="dv">200</span>,height<span class="op">=</span><span class="dv">200</span>)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        F.image_rgba(image<span class="op">=</span>[gaussian_filter(image[::<span class="op">-</span><span class="dv">1</span>,::<span class="op">-</span><span class="dv">1</span>,:],sigma<span class="op">=</span>sigma,mode<span class="op">=</span><span class="st">&#39;constant&#39;</span>,cval<span class="op">=</span><span class="fl">0.0</span>)],x<span class="op">=</span><span class="dv">0</span>,y<span class="op">=</span><span class="dv">0</span>,dw<span class="op">=</span><span class="dv">1</span>,dh<span class="op">=</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        F.title.text<span class="op">=</span><span class="st">&quot;Gaussian Filter sigma=</span><span class="sc">{:.2f}</span><span class="st">&quot;</span>.<span class="bu">format</span>(sigma)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        ims.append(F)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">        </a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="cf">return</span> ims</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">ims<span class="op">=</span>filter_image()</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">show(row(ims))</a></code></pre></div>
<div id="58a42323-f3b6-4db2-8bc8-31b0ee70b70a" class="bk-root" data-root-id="8281">

</div>
<h2 id="padding-and-stride">Padding and stride</h2>
<p><strong>Padding:</strong> One question with filtering (or convolution) is how to handle boundary cases. Let’s suppose for the moment that we are dealing with a discrete convolution kernel, like our 3x3 examples earlier, rather than a continuous one like a Gaussian. What happens when our 3x3 kernel hits an edge of our matrix?</p>
<ol style="list-style-type: decimal">
<li><p>Only consider situations where the kernel fits entirely within the field of the image. If the image is NxM, and the kernel is HxW, then you can fit M-W+1 copies of the kernel in each row and N-H+1 copies of the kernel in each column. So the result of the convolution would have size (N-H+1)x(M-W+1).</p></li>
<li><p>Pad the image (on each side, or top and bottom or both) by zeros – in other words, allow the kernel to overlap the edge of the image, but assume the image is zeros outside of the original bounds. If we add p columns of zeros to each side of the image, then our padded image has M+2p columns and so we can fit M-W+2p+1 copies of the kernel horizontally; and similarly N-H+2p-1 vertically. <strong>Note</strong>: Commonly we can choose W=H, both odd, and then p=(W-1)/2, and we end up with our convolution producing output of the same size as the original image.</p></li>
</ol>
<p><strong>Stride:</strong> What if we move our filter by more than one step each time? The step size is called the <em>stride</em> s. In this case the output size is going to be (M-W+2p)/s+1.</p>
<h3 id="discrete-fourier-transform">Discrete Fourier Transform</h3>
<p>Let <span class="math inline">\(G=\mathbf{Z}/\mathbf{NZ}\)</span>. The <em>characters</em> of <span class="math inline">\(G\)</span> are the homomorphisms <span class="math inline">\(G\to \mathbf{C}^{*}\)</span> where <span class="math inline">\(\mathbf{C}^{*}\)</span> is the multiplicative group of nonzero complex numbers. In other words, a character of <span class="math inline">\(G\)</span> is a function <span class="math inline">\(f:G\to \mathbf{C}^{*}\)</span> with <span class="math inline">\(f(x+y)=f(x)f(y)\)</span>.</p>
<p>For <span class="math inline">\(j=0,\ldots, N-1\)</span>, the function <span class="math display">\[
f_j(x)=e^{2\pi i jx/N}
\]</span> is a character – it is well defined because of you replace <span class="math inline">\(x\)</span> by <span class="math inline">\(x+N\)</span> the value <span class="math inline">\(f_j(x)\)</span> doesn’t change. If <span class="math inline">\(h\)</span> is any function from <span class="math inline">\(G\to \mathbf{C}\)</span>, then there is a unique expansion <span class="math display">\[
h(x) = \sum_{i=0}^{N} \hat{h}(j)f_{j}(x).
\]</span></p>
<p>The <span class="math inline">\(\hat{h}(j)\)</span> are called the Fourier coefficients of <span class="math inline">\(h\)</span>. To prove this, introduce the Hermitian inner product: <span class="math display">\[
&lt;h,k&gt; = \sum_{i=0}^{N-1} h(x)\overline{k}(x)
\]</span></p>
<p>On the one hand the vector space of functions on <span class="math inline">\(G\)</span> is <span class="math inline">\(N\)</span> dimensional; on the other hand you can show that the <span class="math inline">\(N\)</span> functions <span class="math inline">\(f_j\)</span> form an orthogonal basis of the space.</p>
<p>The Fourier coefficients are the projection of the function <span class="math inline">\(h\)</span> onto the corresponding orthonormal basis: <span class="math display">\[
\hat{h}(j) = \frac{&lt;h,f_{-j}&gt;}{N}
\]</span></p>
<h3 id="fast-multiplication">Fast Multiplication</h3>
<p>Suppose you want to multiply two polynomials of degree <span class="math inline">\(d-1\)</span>. If <span class="math inline">\(f(x)=\sum_{i=0}^{d-1} a(i)x^i\)</span> and <span class="math inline">\(g(x)=\sum_{i=0}^{d-1} b(i)x^i\)</span> then the coefficients <span class="math inline">\(c(k)\)</span> of the product are given by <span class="math display">\[
c(k) = \sum_{i+j=k}a(i)b(j) = \sum_{i=0}^{2d}a(i)b(k-i)
\]</span> for <span class="math inline">\(k=0,\ldots, 2d\)</span>. Notice that the sum on the right is the convolution of the two functions <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>; so thinking of these as functions on the positive integers we see that the <span class="math inline">\(k^{th}\)</span> coefficient of <span class="math inline">\(fg\)</span> is <span class="math inline">\((a * b)(k)\)</span>. Also notice this requires <span class="math inline">\(O(d^2)\)</span> multiplications.</p>
<p>Let’s think of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> as functions <span class="math inline">\(\mathbf{Z}/(2d\mathbf{Z})\to \mathbf{C}\)</span>.</p>
<p>We can: - compute the Fourier Transforms <span class="math inline">\(\hat{a}\)</span> and <span class="math inline">\(\hat{b}\)</span> of the functions <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.<br />
- compute the pointwise product <span class="math inline">\(\hat{a}\hat{b}=\hat{c}\)</span>. - compute the inverse Fourier transform of <span class="math inline">\(\hat{c}\)</span> to recover the function <span class="math inline">\(c\)</span>.</p>
<p>This is only a good idea if it is more efficient then the direct multiplication. However, there is an algorithm known as the <em>Fast Fourier Transform</em> which computes <span class="math inline">\(\hat{a}\)</span> and <span class="math inline">\(\hat{b}\)</span>, and then <span class="math inline">\(\hat{\hat{c}}\)</span>, in time <span class="math inline">\(O(d\log d)\)</span>, which is better than the <span class="math inline">\(O(d^2)\)</span> of the original method. For <span class="math inline">\(d\)</span> large this gives a much more efficient way to multiply polynomials.</p>
<p>Applied to integers (which are sort of polynomials in powers of 10, or powers of 2) one gets a fast algorithm for multiplying large integers.</p>
</div>
</body>
</html>
